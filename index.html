<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <meta name="worker-base" content="https://vavlo-worker.bear-8c2.workers.dev">

  <title>Vavlo - Image Annotation Tool</title>
  <style>
    :root{
      --bg:#0f1221; --panel:#171a2c; --panel-2:#1f2340; --line:#2b315a; --text:#e7e9ff; --muted:#a6abd3; --pink:#ff2b85; --gray:#6b7280; --danger:#ef4444; --ok:#10b981; --blue:#3b82f6; --violet:#8b5cf6; --yellow:#f59e0b;
      --z:1; /* scale factor for constant-size markers/tooltips */
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{margin:0;background:var(--bg);color:var(--text);font:14px/1.35 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Noto Sans,Helvetica,Arial; overflow-x:hidden}
    a{color:inherit; text-decoration:none}
    .sr{position:absolute;left:-9999px}

    @media (max-width: 768px){ body{font-size:15px;line-height:1.4} }
    @media (max-width: 480px){ body{font-size:14px;line-height:1.3} }

    /* Topbar */
    .topbar{
      display:flex;align-items:center;gap:12px;
      padding:10px 14px;background:var(--panel);
      border-bottom:1px solid var(--line);position:sticky;top:0;z-index:50
    }
    .brand{display:flex;align-items:center}
    .brand img{height:22px}
    .spacer{flex:1}

    select,.btn,input[type="text"],textarea{
      appearance:none;border:1px solid var(--line);background:var(--panel-2);color:var(--text);
      border-radius:8px;padding:8px 10px
    }
    select:focus,.btn:focus,input:focus,textarea:focus{outline:2px solid var(--pink);outline-offset:2px}
    .btn{cursor:pointer;display:inline-flex;align-items:center;gap:8px}
    .btn.primary{background:var(--pink);border-color:var(--pink);color:#fff}
    .icon-btn{width:34px;height:34px;display:inline-grid;place-items:center;border-radius:8px}
    .pill{font-size:12px;color:var(--muted);white-space:nowrap}

    /* Layout */
    .wrap{display:grid;grid-template-columns:minmax(0,1fr) 380px;height:calc(100% - 58px)}
    .canvas-area{position:relative;overflow:auto;background:radial-gradient(1200px 1200px at 50% -10%, #1a1f3e, #0f1221 60%)}
    .canvas-area.pan-active{cursor:grabbing !important}
    .sidebar{border-left:1px solid var(--line);background:var(--panel);overflow:auto}

    @media (max-width: 980px){
      .wrap{grid-template-columns:1fr}
      .sidebar{order:2}
    }

    /* Dropzone */
    .dropzone{border:2px dashed var(--line);border-radius:16px;padding:24px;margin:16px;text-align:center;background:rgba(255,255,255,0.02)}
    .dropzone .logo{display:block;margin:0 auto 12px auto;height:42px}
    .dropzone h3{margin:6px 0 4px 0}
    .muted{color:var(--muted)}

    /* Stage and image viewport */
    .stage{position:relative;margin:0;border:none;border-radius:0;background:transparent}
    .image-viewport{
      position:relative;width:100%;height:auto;max-height:none;
      overflow:visible; /* let the page handle scrolling */
      padding:0; margin:0;
    }
    .image-viewport.panning{cursor:grab !important}
    .image-viewport.panning:active{cursor:grabbing !important}
    .image-viewport.pan-active{cursor:grabbing !important}
    .image-inner{position:relative;transform-origin:top left}
    .image-inner img{
      position:relative;z-index:1;display:block;
      max-width:none; /* we control scale via transform */
    }

    /* Markers */
    .marker{position:absolute;z-index:2;width:22px;height:22px;border-radius:999px;display:grid;place-items:center;color:#fff;font-size:12px;font-weight:700;cursor:pointer;box-shadow:0 2px 8px rgba(0,0,0,.35);transform:translate(-50%,-50%) scale(calc(1 / var(--z, 1))) !important}
    .marker.unresolved{background:var(--pink)}
    .marker.resolved{background:var(--gray)}
    .marker.active{outline:3px solid rgba(255,255,255,.35)}
    .marker.pending{opacity:.75;animation:pulse 1.4s ease-in-out infinite}
    @keyframes pulse{0%,100%{transform:translate(-50%,-50%) scale(calc(1 / var(--z, 1)))}50%{transform:translate(-50%,-50%) scale(calc(1.15 / var(--z, 1)))}}
    .tooltip{position:absolute;padding:6px 8px;background:rgba(0,0,0,.85);color:#fff;border-radius:6px;font-size:12px;pointer-events:none;transform:translate(-50%,-120%) scale(calc(1 / var(--z, 1))) !important; transform-origin:bottom center; white-space:nowrap}

    /* Instructions section */
    .instructions{
      background:var(--panel-2);
      border:1px solid var(--line);
      border-radius:8px;
      margin:12px 14px;
      padding:12px;
    }
    .instructions h4{
      margin:0 0 8px 0;
      color:var(--pink);
      font-size:13px;
      font-weight:600;
      text-transform:uppercase;
      letter-spacing:0.5px;
    }
    .instructions ul{
      margin:0;
      padding-left:16px;
      font-size:12px;
      color:var(--muted);
      line-height:1.4;
    }
    .instructions li{
      margin-bottom:4px;
    }

    /* Sidebar */
    .side-head{display:flex;align-items:center;justify-content:space-between;padding:12px 14px;border-bottom:1px solid var(--line)}
    .filters{display:flex;gap:8px;align-items:center}
    .comments{padding:12px}
    .comment{border:1px solid var(--line);border-radius:12px;padding:12px;margin-bottom:14px;background:var(--panel-2)}
    .comment.resolved{background:#22263e}
    .comment .row{display:flex;align-items:center;gap:8px;margin-bottom:6px}
    .badge{background:var(--pink);color:#fff;font-weight:800;padding:2px 8px;border-radius:999px}
    .badge.resolved{background:var(--gray)}
    .comment .meta{color:var(--muted);font-size:12px}
    .comment .text{margin:6px 0 10px 0}
    .comment .reply-area{margin-top:8px;border-top:1px dashed var(--line);padding-top:8px}
    .reply{border-left:3px solid var(--line);margin:6px 0 0 8px;padding-left:8px}

    .comment-actions{display:flex;flex-wrap:wrap;gap:6px}
    .comment-actions .btn{font-size:12px;padding:6px 10px;background:var(--panel);border:1px solid var(--line);color:var(--text)}
    .comment-actions .btn:hover{background:var(--panel-2)}
    .reply-actions{display:flex;flex-wrap:wrap;gap:6px;margin-top:6px;padding-top:6px;border-top:1px dashed var(--line)}
    .reply-actions .btn{font-size:11px;padding:4px 8px;background:var(--panel);border:1px solid var(--line);color:var(--muted)}

    .form-row{margin:8px 0}

    /* Share controls in topbar */
    .share-controls{display:flex;align-items:center;gap:8px;min-width:260px;max-width:520px;width:40%}
    #shareLink{flex:1;min-width:0}

    /* Zoom */
    #zoomReset{min-width:90px;text-align:center}

    /* Pan mode indicator */
    .pan-indicator{
      position:fixed;
      top:70px;
      left:20px;
      background:var(--pink);
      color:#fff;
      padding:6px 12px;
      border-radius:6px;
      font-size:12px;
      font-weight:600;
      z-index:100;
      opacity:0;
      transition:opacity 0.2s;
      pointer-events:none;
    }
    .pan-indicator.active{opacity:1}
  </style>
</head>
<body>
  <!-- Pan mode indicator -->
  <div class="pan-indicator" id="panIndicator">Pan Mode - Drag to move image</div>

  <!-- TOPBAR -->
  <div class="topbar">
    <a href="https://vavlo.io" class="brand" target="_blank" rel="noopener">
      <img src="Vavlo - logo- white@1000x.png" alt="Vavlo"/>
    </a>

    <!-- Versions -->
    <div class="versions">
      <label for="version" class="sr">Version</label>
      <select id="version" title="Version" data-testid="version-select">
        <option value="">v0</option>
      </select>
    </div>

    <!-- Upload new version with icon -->
    <button class="btn" id="uploadNewVersion" data-testid="btn-upload-version" title="Upload new version">
      <!-- inline svg icon -->
      <svg width="16" height="16" viewBox="0 0 24 24" aria-hidden="true">
        <path fill="currentColor" d="M12 3l4 4h-3v6h-2V7H8l4-4zm-7 14h14v2H5v-2z"/>
      </svg>
      Upload New Version
    </button>

    <!-- Zoom -->
    <div class="zoom-group" style="margin-left:6px">
      <button class="btn icon-btn" id="zoomOut" data-testid="btn-zoom-out" title="Zoom out" aria-label="Zoom out">-</button>
      <button class="btn icon-btn" id="zoomReset" data-testid="btn-zoom-reset" title="Reset zoom" aria-label="Reset zoom">100%</button>
      <button class="btn icon-btn" id="zoomIn" data-testid="btn-zoom-in" title="Zoom in" aria-label="Zoom in">+</button>
    </div>

    <div class="spacer"></div>

    <!-- Share controls restored with both options -->
    <div class="share-controls">
      <input id="shareLink" type="text" readonly placeholder="Share link will appear here"/>
      <button class="btn primary" id="copyShare" title="Copy share link">Copy</button>
      <button class="btn" id="downloadHTML" title="Download backup HTML file">Download</button>
    </div>

    <!-- Project info -->
    <div class="pill">Expires: <span id="expiresText">-</span></div>
    <div class="pill">Accesses: <span id="accessText">0</span></div>
  </div>

  <!-- MAIN WRAP -->
  <div class="wrap">
    <main class="canvas-area">
      <!-- Dropzone -->
      <div class="dropzone" id="dropzone">
        <img class="logo" src="Vavlo - logo- white@1000x.png" alt="Vavlo"/>
        <h3>Drag and drop your image here</h3>
        <div class="muted">or click to browse files</div>
        <div style="margin-top:10px"><button class="btn" id="chooseFile">Choose File</button></div>
        <input id="fileInput" type="file" accept="image/*" hidden/>
      </div>

      <!-- Stage with no frame -->
      <section class="stage" id="stage" hidden>
        <div class="image-viewport" id="viewport">
          <div class="image-inner" id="imageInner">
            <img id="img" alt="Uploaded"/>
            <!-- markers injected here -->
          </div>
        </div>
      </section>
    </main>

    <!-- Sidebar -->
    <aside class="sidebar">
      <!-- Instructions section -->
      <div class="instructions">
        <h4>How to Use</h4>
        <ul>
          <li><strong>Click</strong> on any part of the image to add a comment</li>
          <li><strong>Hold Spacebar + Drag</strong> to pan around the image</li>
          <li><strong>Use zoom controls</strong> or scroll wheel to zoom in/out</li>
          <li><strong>Filter comments</strong> by status using the dropdown below</li>
        </ul>
      </div>

      <div class="side-head">
        <strong>Comments</strong>
        <div class="filters">
          <select id="filterSelect" title="Filter">
            <option value="all">All</option>
            <option value="unresolved" selected>Unresolved</option>
            <option value="resolved">Resolved</option>
          </select>
        </div>
      </div>
      <div id="comments" class="comments">
        <!-- comments appear here -->
      </div>
    </aside>
  </div>

  <script>
    /** TYPES
     * @typedef {{rid:number, author:string, text:string, createdAt:string}} ReplyItem
     * @typedef {{ id:number, xPct:number, yPct:number, resolved:boolean, author:string, text:string, createdAt:string, replies:ReplyItem[] }} CommentItem
     * @typedef {{ imageSrc:string, comments:CommentItem[], nextId:number }} VersionPayload
     */

    const state = {
      projectId: null,
      createdAt: null,
      expiresAt: null,
      accessCount: 0,
      versionOrder: [],
      versions: {},
      currentVersion: null,
      sharedMode: false,
      scale: 1,
      minScale: 0.1,
      maxScale: 5,
      imgNatural: { w: 0, h: 0 },
      panning: false,
      panStart: { x: 0, y: 0 },
      scrollStart: { x: 0, y: 0 },
      spacePressed: false,
    };

    const AUTHOR_KEY = 'vavlo.author';
    function getSavedAuthor(){ try{ return localStorage.getItem(AUTHOR_KEY) || ''; }catch{ return ''; } }
    function setSavedAuthor(v){ try{ localStorage.setItem(AUTHOR_KEY, v || ''); }catch{} }

    // Static file generation approach - much simpler and more reliable
    let workerBase = 'static-files';
    async function resolveWorkerBase(){
      console.log('Using static file generation for persistence...');
      console.log('Projects will be saved as individual HTML files');
      return 'static-files';
    }

    // Generate a complete standalone HTML file for the project
    function generateProjectHTML(projectData) {
      return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Vavlo Project - ${projectData.projectId.substring(0, 8)}</title>
  <style>
    :root{
      --bg:#0f1221; --panel:#171a2c; --panel-2:#1f2340; --line:#2b315a; --text:#e7e9ff; --muted:#a6abd3; --pink:#ff2b85; --gray:#6b7280;
    }
    *{box-sizing:border-box}
    html,body{height:100%; margin:0; font:14px/1.35 system-ui; background:var(--bg); color:var(--text)}
    .header{padding:20px; text-align:center; border-bottom:1px solid var(--line)}
    .header h1{margin:0; color:var(--pink)}
    .container{max-width:1400px; margin:0 auto; display:grid; grid-template-columns:1fr 400px; gap:20px; padding:20px}
    .image-area{position:relative}
    .image-area img{max-width:100%; height:auto; border-radius:8px}
    .marker{position:absolute; width:22px; height:22px; border-radius:50%; display:grid; place-items:center; color:#fff; font-size:12px; font-weight:700; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.35); transform:translate(-50%,-50%)}
    .marker.unresolved{background:var(--pink)}
    .marker.resolved{background:var(--gray)}
    .comments{background:var(--panel); border-radius:12px; padding:20px; max-height:80vh; overflow-y:auto}
    .comment{border:1px solid var(--line); border-radius:8px; padding:12px; margin-bottom:12px; background:var(--panel-2)}
    .comment.resolved{opacity:0.7}
    .comment-header{display:flex; align-items:center; gap:8px; margin-bottom:8px}
    .badge{background:var(--pink); color:#fff; font-weight:800; padding:2px 8px; border-radius:999px; font-size:11px}
    .badge.resolved{background:var(--gray)}
    .meta{color:var(--muted); font-size:12px}
    .comment-text{margin:8px 0}
    .reply{border-left:3px solid var(--line); margin:8px 0 0 12px; padding-left:12px; font-size:13px}
    .footer{text-align:center; padding:20px; color:var(--muted); font-size:12px}
    
    @media (max-width: 900px){
      .container{grid-template-columns:1fr; gap:10px}
      .comments{max-height:none}
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>Vavlo Project Review</h1>
    <div class="meta">Created: ${new Date(projectData.createdAt).toLocaleDateString()} ‚Ä¢ Accessed: ${projectData.accessCount} times</div>
  </div>
  
  <div class="container">
    <div class="image-area">
      <img src="${projectData.versions[projectData.currentVersion].imageSrc}" alt="Project Image" id="projectImage"/>
      ${projectData.versions[projectData.currentVersion].comments.map(comment => `
        <div class="marker ${comment.resolved ? 'resolved' : 'unresolved'}" 
             style="left:${comment.xPct}%; top:${comment.yPct}%"
             data-id="${comment.id}">${comment.id}</div>
      `).join('')}
    </div>
    
    <div class="comments">
      <h3>Comments (${projectData.versions[projectData.currentVersion].comments.length})</h3>
      ${projectData.versions[projectData.currentVersion].comments.map((comment, index) => `
        <div class="comment ${comment.resolved ? 'resolved' : ''}" id="comment-${comment.id}">
          <div class="comment-header">
            <span class="badge ${comment.resolved ? 'resolved' : ''}">#${index + 1}</span>
            <strong>${comment.author || 'Anonymous'}</strong>
            <span class="meta">${new Date(comment.createdAt).toLocaleDateString()}</span>
            <span class="meta">${comment.resolved ? 'Resolved' : 'Open'}</span>
          </div>
          <div class="comment-text">${comment.text}</div>
          ${comment.replies.map(reply => `
            <div class="reply">
              <div class="meta"><strong>${reply.author || 'Anonymous'}</strong> ‚Ä¢ ${new Date(reply.createdAt).toLocaleDateString()}</div>
              <div>${reply.text}</div>
            </div>
          `).join('')}
        </div>
      `).join('')}
    </div>
  </div>
  
  <div class="footer">
    <div>Generated by Vavlo ‚Ä¢ <a href="https://vavlo.io" style="color:var(--pink)">Create your own project</a></div>
  </div>
  
  <script>
    // Add click handlers for markers
    document.querySelectorAll('.marker').forEach(marker => {
      marker.addEventListener('click', () => {
        const commentId = marker.dataset.id;
        const commentEl = document.getElementById('comment-' + commentId);
        if (commentEl) {
          commentEl.scrollIntoView({ behavior: 'smooth', block: 'center' });
          commentEl.style.background = 'rgba(255, 43, 133, 0.1)';
          setTimeout(() => {
            commentEl.style.background = '';
          }, 2000);
        }
      });
    });
  </script>
</body>
</html>`;
    }

    // Elements
    const dropzone = document.getElementById('dropzone');
    const chooseFileBtn = document.getElementById('chooseFile');
    const fileInput = document.getElementById('fileInput');
    const stage = document.getElementById('stage');
    const img = document.getElementById('img');
    const imageInner = document.getElementById('imageInner');
    const viewport = document.getElementById('viewport');
    const canvasArea = document.querySelector('.canvas-area');
    const commentsEl = document.getElementById('comments');
    const filterSelect = document.getElementById('filterSelect');
    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomResetBtn = document.getElementById('zoomReset');
    const versionSelect = document.getElementById('version');
    const uploadBtn = document.getElementById('uploadNewVersion');
    const expiresText = document.getElementById('expiresText');
    const accessText = document.getElementById('accessText');
    const shareInput = document.getElementById('shareLink');
    const copyBtn = document.getElementById('copyShare');
    const downloadBtn = document.getElementById('downloadHTML');
    const panIndicator = document.getElementById('panIndicator');

    // Versions
    function setVersions(list){
      const uniq = Array.from(new Set(list));
      uniq.sort((a,b)=> (parseInt(b.replace(/\D/g,''))||0) - (parseInt(a.replace(/\D/g,''))||0)).reverse();
      state.versionOrder = uniq;
      versionSelect.innerHTML = '';
      if (uniq.length === 0) {
        const defaultOpt = document.createElement('option');
        defaultOpt.value = '';
        defaultOpt.textContent = 'v0';
        versionSelect.appendChild(defaultOpt);
      } else {
        uniq.forEach(v => {
          const opt = document.createElement('option'); opt.value = v; opt.textContent = v; versionSelect.appendChild(opt);
        });
      }
      if (state.currentVersion == null && uniq.length){ state.currentVersion = uniq[0]; }
      versionSelect.value = state.currentVersion || '';
    }
    versionSelect.addEventListener('change', ()=>{ const v = versionSelect.value; if (!v) return; state.currentVersion = v; renderAll(); });

    // Smart zoom system
    function getSmartZoomLevel(direction) {
      const currentZoom = state.scale;
      const zoomLevels = [0.1, 0.25, 0.33, 0.5, 0.67, 0.75, 1, 1.25, 1.5, 2, 2.5, 3, 4, 5];
      
      if (direction === 'in') {
        // Find the next higher zoom level
        for (let level of zoomLevels) {
          if (level > currentZoom + 0.01) { // small tolerance for float comparison
            return level;
          }
        }
        return state.maxScale;
      } else {
        // Find the next lower zoom level
        for (let i = zoomLevels.length - 1; i >= 0; i--) {
          if (zoomLevels[i] < currentZoom - 0.01) {
            return zoomLevels[i];
          }
        }
        return state.minScale;
      }
    }

    // Zoom and fit with proper scrollable content creation
    function applyScale(){
      imageInner.style.transform = `scale(${state.scale})`;
      imageInner.style.setProperty('--z', String(state.scale)); // keep markers/tooltips same visual size
      zoomResetBtn.textContent = Math.round(state.scale * 100) + '%';
      
      if (state.imgNatural.h && state.imgNatural.w){
        // Create scrollable content by making viewport larger than canvas-area
        const scaledWidth = state.imgNatural.w * state.scale;
        const scaledHeight = state.imgNatural.h * state.scale;
        
        // Ensure viewport is at least as large as the scaled image
        const minWidth = Math.max(scaledWidth, canvasArea.clientWidth);
        const minHeight = Math.max(scaledHeight, canvasArea.clientHeight);
        
        viewport.style.width = minWidth + 'px';
        viewport.style.height = minHeight + 'px';
        viewport.style.minWidth = scaledWidth + 'px';
        viewport.style.minHeight = scaledHeight + 'px';
        
        console.log('Applied scale with scrollable content:', {
          scale: state.scale,
          natural: { w: state.imgNatural.w, h: state.imgNatural.h },
          scaled: { w: scaledWidth, h: scaledHeight },
          viewport: { w: minWidth, h: minHeight },
          canvasArea: { w: canvasArea.clientWidth, h: canvasArea.clientHeight },
          scrollable: { w: canvasArea.scrollWidth, h: canvasArea.scrollHeight }
        });
      }
    }
    function fitToViewport(){
      if (!state.versions[state.currentVersion]) return;
      const vw = viewport.clientWidth;           // fit width so we avoid horizontal scroll
      const sx = vw / state.imgNatural.w;
      // cap at 1 so we do not upscale by default
      state.scale = Math.min(1, Math.max(sx, 0.1));
      applyScale();
    }
    zoomInBtn.addEventListener('click', ()=>{ state.scale = getSmartZoomLevel('in'); applyScale(); });
    zoomOutBtn.addEventListener('click', ()=>{ state.scale = getSmartZoomLevel('out'); applyScale(); });
    zoomResetBtn.addEventListener('click', fitToViewport);
    window.addEventListener('resize', ()=>{ if (!stage.hidden) fitToViewport(); });

    // Improved spacebar panning functionality for Mac compatibility
    function updatePanMode() {
      if (state.spacePressed && !stage.hidden) {
        viewport.classList.add('panning');
        canvasArea.classList.add('panning');
        panIndicator.classList.add('active');
        console.log('üéØ Pan mode enabled');
      } else {
        viewport.classList.remove('panning');
        canvasArea.classList.remove('panning');
        panIndicator.classList.remove('active');
        state.panning = false;
        canvasArea.classList.remove('pan-active');
        console.log('üéØ Pan mode disabled');
      }
    }

    // Use both keydown and keyup for better cross-platform support
    document.addEventListener('keydown', (e) => {
      // Check for spacebar - use both 'Space' and ' ' for compatibility
      if ((e.code === 'Space' || e.key === ' ') && !e.repeat) {
        // Don't interfere with input fields
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA' || 
            e.target.contentEditable === 'true') {
          return;
        }
        
        // Prevent ALL default spacebar behavior
        e.preventDefault();
        e.stopPropagation();
        state.spacePressed = true;
        updatePanMode();
      }
    });

    document.addEventListener('keyup', (e) => {
      if (e.code === 'Space' || e.key === ' ') {
        e.preventDefault();
        e.stopPropagation();
        state.spacePressed = false;
        updatePanMode();
      }
    });

    // Prevent spacebar scrolling globally
    window.addEventListener('keydown', (e) => {
      if ((e.code === 'Space' || e.key === ' ') && 
          e.target.tagName !== 'INPUT' && 
          e.target.tagName !== 'TEXTAREA' && 
          e.target.contentEditable !== 'true') {
        e.preventDefault();
      }
    }, true);

    // Focus management to ensure spacebar works
    window.addEventListener('focus', () => {
      state.spacePressed = false;
      updatePanMode();
    });

    // Pan mode with improved event handling and debugging
    canvasArea.addEventListener('mousedown', (e) => {
      if (state.spacePressed && !stage.hidden) {
        e.preventDefault();
        e.stopPropagation();
        state.panning = true;
        state.panStart = { x: e.clientX, y: e.clientY };
        state.scrollStart = { 
          x: canvasArea.scrollLeft, 
          y: canvasArea.scrollTop 
        };
        canvasArea.classList.add('pan-active');
        
        console.log('Pan started:', { 
          panStart: state.panStart, 
          scrollStart: state.scrollStart,
          canvasScrollable: { 
            scrollWidth: canvasArea.scrollWidth, 
            scrollHeight: canvasArea.scrollHeight,
            clientWidth: canvasArea.clientWidth,
            clientHeight: canvasArea.clientHeight,
            scrollLeft: canvasArea.scrollLeft,
            scrollTop: canvasArea.scrollTop
          },
          viewportSize: {
            width: viewport.clientWidth,
            height: viewport.clientHeight
          }
        });
      }
    });

    // Use both mousemove events for better coverage
    canvasArea.addEventListener('mousemove', (e) => {
      if (state.panning && state.spacePressed) {
        e.preventDefault();
        e.stopPropagation();
        const deltaX = state.panStart.x - e.clientX;
        const deltaY = state.panStart.y - e.clientY;
        
        const newScrollLeft = state.scrollStart.x + deltaX;
        const newScrollTop = state.scrollStart.y + deltaY;
        
        canvasArea.scrollLeft = newScrollLeft;
        canvasArea.scrollTop = newScrollTop;
        
        console.log('Local pan event:', { 
          delta: { x: deltaX, y: deltaY },
          scroll: { left: canvasArea.scrollLeft, top: canvasArea.scrollTop }
        });
      }
    });

    document.addEventListener('mousemove', (e) => {
      if (state.panning && state.spacePressed) {
        e.preventDefault();
        e.stopPropagation();
        const deltaX = state.panStart.x - e.clientX;
        const deltaY = state.panStart.y - e.clientY;
        
        const newScrollLeft = state.scrollStart.x + deltaX;
        const newScrollTop = state.scrollStart.y + deltaY;
        
        canvasArea.scrollLeft = newScrollLeft;
        canvasArea.scrollTop = newScrollTop;
        
        console.log('Global pan event:', { 
          delta: { x: deltaX, y: deltaY },
          scroll: { left: canvasArea.scrollLeft, top: canvasArea.scrollTop }
        });
      }
    });

    document.addEventListener('mouseup', (e) => {
      if (state.panning) {
        e.preventDefault();
        state.panning = false;
        canvasArea.classList.remove('pan-active');
        console.log('Pan ended');
      }
    });

    // Mouse wheel zoom
    viewport.addEventListener('wheel', (e) => {
      if (e.ctrlKey || e.metaKey) {
        e.preventDefault();
        if (e.deltaY < 0) {
          state.scale = getSmartZoomLevel('in');
        } else {
          state.scale = getSmartZoomLevel('out');
        }
        applyScale();
      }
    });

    // Uploads - Fix double click issue
    chooseFileBtn.addEventListener('click', (e) => {
      e.stopPropagation(); // prevent dropzone click
      fileInput.click();
    });
    
    // Only add click to dropzone area, not the button
    dropzone.addEventListener('click', (e) => {
      if (e.target === chooseFileBtn || chooseFileBtn.contains(e.target)) {
        return; // don't trigger if clicking the button
      }
      fileInput.click();
    });
    
    dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.style.borderColor = 'var(--pink)'; });
    dropzone.addEventListener('dragleave', ()=> { dropzone.style.borderColor = 'var(--line)'; });
    dropzone.addEventListener('drop', e => { e.preventDefault(); dropzone.style.borderColor = 'var(--line)'; const file = e.dataTransfer.files && e.dataTransfer.files[0]; if (file) addNewVersionFromFile(file); });
    fileInput.addEventListener('change', e => { const file = e.target.files && e.target.files[0]; if (file) addNewVersionFromFile(file); });

    uploadBtn.addEventListener('click', () => {
      if (state.sharedMode) { alert('Uploading new versions is disabled for shared viewers.'); return; }
      fileInput.click();
    });

    async function ensureProjectIdAndLink(){
      if (!state.projectId){
        state.projectId = cryptoRandomId(64);
        state.createdAt = new Date().toISOString();
        state.expiresAt = new Date(Date.now() + 90*24*60*60*1000).toISOString();
        state.accessCount = 0;
        console.log('Created new project:', state.projectId);
      }
      // Clean share link format - just use the project ID
      const appUrl = `${location.origin}${location.pathname}?shared=${state.projectId}`;
      if (shareInput){ 
        shareInput.value = appUrl; 
        console.log('üîó Set share link to clean format:', appUrl);
      }
      await saveProject();
    }

    async function addNewVersionFromFile(file){
      if (state.sharedMode){ alert('Uploading new versions is disabled for shared viewers.'); return; }
      if (!file) return;
      const url = URL.createObjectURL(file);
      await ensureProjectIdAndLink();
      await addVersionFromImageURL(url);
    }

    async function addVersionFromImageURL(url){
      const imgLoad = new Image();
      imgLoad.onload = () => {
        const nextNum = Math.max(0, ...state.versionOrder.map(v=> parseInt(v.replace(/\D/g,''))||0)) + 1;
        const vKey = `v${nextNum}`;
        state.versions[vKey] = { imageSrc: url, comments: [], nextId: 1 };
        state.imgNatural.w = imgLoad.naturalWidth; state.imgNatural.h = imgLoad.naturalHeight;
        imageInner.style.width = state.imgNatural.w + 'px'; imageInner.style.height = state.imgNatural.h + 'px';
        setVersions([vKey, ...state.versionOrder]);
        state.currentVersion = vKey;
        stage.hidden = false; dropzone.hidden = true; renderAll(); fitToViewport(); 
        
        // FORCE clean share link format here too
        if (shareInput && state.projectId) {
          const cleanUrl = `${location.origin}${location.pathname}?shared=${state.projectId}`;
          shareInput.value = cleanUrl;
          console.log('Set clean share URL after image upload:', cleanUrl);
        }
        
        autoSave();
      };
      imgLoad.src = url;
    }

    imageInner.addEventListener('click', (e) => {
      if (e.target.classList.contains('marker')) return;
      if (state.panning || state.spacePressed) return; // don't add comments while panning
      
      const rect = imageInner.getBoundingClientRect();
      const xScaled = e.clientX - rect.left; const yScaled = e.clientY - rect.top;
      const x = xScaled / state.scale; const y = yScaled / state.scale;
      const xPct = (x / state.imgNatural.w) * 100; const yPct = (y / state.imgNatural.h) * 100;
      openNewCommentForm(xPct, yPct);
    });

    // Pending marker helpers
    function showPendingMarker(xPct, yPct){
      const existing = imageInner.querySelector('.marker.pending'); if (existing) existing.remove();
      const el = document.createElement('div');
      el.className = 'marker unresolved pending';
      el.style.left = xPct + '%';
      el.style.top = yPct + '%';
      el.textContent = '+';
      imageInner.appendChild(el);
    }
    function removePendingMarker(){
      const existing = imageInner.querySelector('.marker.pending'); if (existing) existing.remove();
    }

    function openNewCommentForm(xPct, yPct){
      const namePrefill = getSavedAuthor();
      const container = document.createElement('div'); container.className = 'new-comment comment';
      container.innerHTML = `
        <div><strong>New Comment</strong></div>
        <div class="form-row"><input type="text" class="author-name" placeholder="Your name" value="${sanitize(namePrefill)}"/></div>
        <div class="form-row"><textarea class="author-text" placeholder="Type feedback..."></textarea></div>
        <div class="form-row">
          <button class="btn small" data-action="save-new">Save</button>
          <button class="btn small" data-action="cancel-new">Cancel</button>
        </div>
      `;
      container.dataset.xpct = String(xPct); container.dataset.ypct = String(yPct);
      commentsEl.prepend(container);
      showPendingMarker(xPct, yPct);
    }

    commentsEl.addEventListener('click', (e)=>{
      const t = e.target; if (!(t instanceof HTMLElement)) return;
      const action = t.getAttribute('data-action');
      if (action === 'save-new'){
        const wrap = t.closest('.new-comment'); if (!wrap) return;
        const xPct = +wrap.dataset.xpct; const yPct = +wrap.dataset.ypct;
        const author = (wrap.querySelector('.author-name').value || 'Anon').trim();
        const text = (wrap.querySelector('.author-text').value || '').trim();
        if (!text){ alert('Please add a comment.'); return; }
        setSavedAuthor(author);
        addComment({ xPct, yPct, author, text, resolved:false });
        wrap.remove();
        removePendingMarker();
        return;
      }
      if (action === 'cancel-new'){
        const wrap = t.closest('.new-comment'); if (wrap) wrap.remove();
        removePendingMarker();
        return;
      }

      const id = +(t.getAttribute('data-id') || 0);
      if (!id) return;
      const v = state.versions[state.currentVersion];
      const c = v.comments.find(x=> x.id === id); if (!c) return;

      if (action === 'toggle-resolve'){
        c.resolved = !c.resolved;
        renderMarker(c); renderComments(); autoSave();
        return;
      }
      if (action === 'delete'){
        if (!confirm('Delete this comment?')) return;
        v.comments = v.comments.filter(x=> x.id !== id);
        const m = imageInner.querySelector(`[data-id="${id}"]`); if (m) m.remove();
        renderComments(); autoSave();
        return;
      }
      if (action === 'edit'){
        const editable = commentsEl.querySelector(`.text[data-id="${id}"]`); if (editable){ editable.focus(); }
        return;
      }
      if (action === 'reply'){
        const area = commentsEl.querySelector(`.reply-area[data-id="${id}"]`);
        if (area){ area.innerHTML = replyFormHTML(id); }
        return;
      }
      if (action === 'save-reply'){
        const rid = Date.now();
        const block = t.closest('.reply-area'); if (!block) return;
        const author = (block.querySelector('.reply-author').value || getSavedAuthor() || 'Anon').trim();
        const text = (block.querySelector('.reply-text').value || '').trim();
        if (!text) { alert('Please write a reply.'); return; }
        setSavedAuthor(author);
        c.replies.push({ rid, author, text, createdAt: new Date().toISOString() });
        renderComments(); autoSave();
        return;
      }
      if (action === 'cancel-reply'){
        const block = t.closest('.reply-area'); if (block) block.innerHTML = '';
        return;
      }
      if (action === 'edit-reply'){
        const rid = +(t.getAttribute('data-rid') || 0);
        const editable = commentsEl.querySelector(`.reply-text[data-rid="${rid}"]`); 
        if (editable){ editable.focus(); }
        return;
      }
      if (action === 'delete-reply'){
        const rid = +(t.getAttribute('data-rid') || 0);
        if (!confirm('Delete this reply?')) return;
        c.replies = c.replies.filter(r => r.rid !== rid);
        renderComments(); autoSave();
        return;
      }
      if (action === 'save-reply-edit'){
        const rid = +(t.getAttribute('data-rid') || 0);
        const editable = commentsEl.querySelector(`.reply-text[data-rid="${rid}"]`);
        const reply = c.replies.find(r => r.rid === rid);
        if (editable && reply){ reply.text = editable.textContent || ''; }
        autoSave();
        return;
      }
      if (action === 'submit'){
        const editable = commentsEl.querySelector(`.text[data-id="${id}"]`);
        if (editable){ c.text = editable.textContent || ''; }
        autoSave();
        return;
      }
    });

    function replyFormHTML(id){
      const namePrefill = getSavedAuthor();
      return `
        <div class="form-row"><input type="text" class="reply-author" placeholder="Your name" value="${sanitize(namePrefill)}"/></div>
        <div class="form-row"><textarea class="reply-text" placeholder="Write a reply..."></textarea></div>
        <div class="form-row">
          <button class="btn small" data-action="save-reply" data-id="${id}">Save reply</button>
          <button class="btn small" data-action="cancel-reply" data-id="${id}">Cancel</button>
        </div>
      `;
    }

    commentsEl.addEventListener('input', (e)=>{
      const t = e.target; if (!(t instanceof HTMLElement)) return;
      if (t.classList.contains('text')){
        const id = +(t.getAttribute('data-id') || 0);
        const v = state.versions[state.currentVersion]; const c = v.comments.find(x=> x.id === id);
        if (c){ c.text = t.textContent || ''; autoSaveSoon(); }
      }
      if (t.classList.contains('reply-text')){
        const id = +(t.getAttribute('data-id') || 0);
        const rid = +(t.getAttribute('data-rid') || 0);
        const v = state.versions[state.currentVersion]; const c = v.comments.find(x=> x.id === id);
        const reply = c && c.replies.find(r => r.rid === rid);
        if (reply){ reply.text = t.textContent || ''; autoSaveSoon(); }
      }
    });

    filterSelect.addEventListener('change', ()=> renderComments());

    // Render
    function addComment({ xPct, yPct, author, text, resolved }){
      const v = state.versions[state.currentVersion];
      const id = v.nextId++;
      const c = { id, xPct, yPct, resolved, author, text, createdAt: new Date().toISOString(), replies: [] };
      v.comments.push(c);
      renderMarker(c); renderComments(); autoSave();
    }

    function renderAll(){
      const v = state.versions[state.currentVersion]; if (!v) return;
      img.onload = ()=>{
        state.imgNatural.w = img.naturalWidth; state.imgNatural.h = img.naturalHeight;
        imageInner.style.width = state.imgNatural.w + 'px'; imageInner.style.height = state.imgNatural.h + 'px';
        fitToViewport();
      };
      img.src = v.imageSrc;
      imageInner.querySelectorAll('.marker').forEach(m=> m.remove());
      v.comments.forEach(renderMarker);
      stage.hidden = false; dropzone.hidden = true;
      renderComments(); updateExpiryUI();
    }

    function renderMarker(c){
      const existing = imageInner.querySelector(`[data-id="${c.id}"]`); if (existing) existing.remove();
      const el = document.createElement('div');
      el.className = `marker ${c.resolved ? 'resolved' : 'unresolved'}`;
      el.dataset.id = String(c.id);
      el.style.left = c.xPct + '%'; el.style.top = c.yPct + '%';
      el.textContent = c.id;
      let tip; el.addEventListener('mouseenter', ()=>{ tip = document.createElement('div'); tip.className='tooltip'; tip.textContent = truncate(c.text, 80); el.appendChild(tip); });
      el.addEventListener('mouseleave', ()=>{ if (tip) tip.remove(); });
      el.addEventListener('click', ()=>{ imageInner.querySelectorAll('.marker').forEach(m=> m.classList.remove('active')); el.classList.add('active'); scrollCardIntoView(c.id); });
      imageInner.appendChild(el);
    }

    function renderComments(){
      const v = state.versions[state.currentVersion];
      const filter = filterSelect.value;
      commentsEl.innerHTML = '';
      const filteredComments = v.comments
        .filter(c => filter==='all' ? true : filter==='resolved' ? c.resolved : !c.resolved)
        .sort((a,b)=> new Date(a.createdAt) - new Date(b.createdAt));

      filteredComments.forEach((c, index) => {
        const displayNumber = index + 1;
        const card = document.createElement('div'); card.className = `comment ${c.resolved ? 'resolved':''}`;
        card.innerHTML = `
          <div class="row">
            <span class="badge ${c.resolved ? 'resolved' : ''}">#${displayNumber}</span>
            <span><strong>${sanitize(c.author || 'Anon')}</strong></span>
            <span class="meta">${formatTime(c.createdAt)}</span>
            <span class="meta">${c.resolved ? 'Resolved' : 'Unresolved'}</span>
          </div>
          <div class="text" contenteditable="true" data-id="${c.id}">${sanitize(c.text)}</div>
          <div class="comment-actions">
            <button class="btn" data-action="toggle-resolve" data-id="${c.id}">${c.resolved ? 'Unresolve' : 'Resolve'}</button>
            <button class="btn" data-action="reply" data-id="${c.id}">Reply</button>
            <button class="btn" data-action="edit" data-id="${c.id}">Edit</button>
            <button class="btn" data-action="delete" data-id="${c.id}">Delete</button>
            <button class="btn" data-action="submit" data-id="${c.id}">Save</button>
          </div>
          <div class="reply-area" data-id="${c.id}"></div>
          ${c.replies.map(r => `
            <div class="reply">
              <div class="meta"><strong>${sanitize(r.author || 'Anon')}</strong> ‚Ä¢ ${formatTime(r.createdAt)}</div>
              <div class="reply-text" contenteditable="true" data-rid="${r.rid}" data-id="${c.id}">${sanitize(r.text)}</div>
              <div class="reply-actions">
                <button class="btn" data-action="edit-reply" data-rid="${r.rid}" data-id="${c.id}">Edit</button>
                <button class="btn" data-action="delete-reply" data-rid="${r.rid}" data-id="${c.id}">Delete</button>
                <button class="btn" data-action="save-reply-edit" data-rid="${r.rid}" data-id="${c.id}">Save</button>
              </div>
            </div>
          `).join('')}
        `;
        commentsEl.appendChild(card);
      });
    }

    function scrollCardIntoView(id){
      const v = state.versions[state.currentVersion];
      const filter = filterSelect.value;
      const filteredComments = v.comments
        .filter(c => filter==='all' ? true : filter==='resolved' ? c.resolved : !c.resolved)
        .sort((a,b)=> new Date(a.createdAt) - new Date(b.createdAt));
      const commentIndex = filteredComments.findIndex(c => c.id === id);
      if (commentIndex >= 0) {
        const displayNumber = commentIndex + 1;
        const card = Array.from(commentsEl.children).find(el => el.querySelector && el.querySelector('.badge') && el.querySelector('.badge').textContent === `#${displayNumber}`);
        if (card) card.scrollIntoView({ behavior:'smooth', block:'center' });
      }
    }

    // Share with debugging
    async function copyShareLink(){
      let link = shareInput && shareInput.value ? shareInput.value : '';
      console.log('üìã Current share link value:', link);
      
      if (!link){ 
        await ensureProjectIdAndLink(); 
        link = shareInput.value; 
        console.log('üìã Generated new share link:', link);
      }
      
      // Double-check the format
      if (link.includes('vavlo-worker') || link.includes('bear-8c2')) {
        console.error('‚ùå Share link still contains worker URL! Fixing...');
        const cleanLink = `${location.origin}${location.pathname}?shared=${state.projectId}`;
        shareInput.value = cleanLink;
        link = cleanLink;
        console.log('üîß Fixed share link to:', link);
      }
      
      try{ 
        await navigator.clipboard.writeText(link); 
        alert('Share link copied: ' + link); 
      } catch(e) { 
        alert('Copy failed'); 
      }
    }
    copyBtn.addEventListener('click', copyShareLink);

    // Save as downloadable HTML file - much simpler approach
    async function saveProject(){
      try{
        if (!state.projectId) {
          console.error('‚ùå Cannot save: No project ID');
          return;
        }

        const payload = {
          projectId: state.projectId,
          createdAt: state.createdAt,
          expiresAt: state.expiresAt,
          accessCount: state.accessCount,
          versionOrder: state.versionOrder,
          currentVersion: state.currentVersion,
          versions: state.versions,
          updatedAt: new Date().toISOString()
        };
        
        console.log('üíæ Generating standalone HTML file...');
        console.log('- Project ID:', state.projectId);
        
        // Generate the complete HTML file
        const htmlContent = generateProjectHTML(payload);
        
        // Save to localStorage as backup
        localStorage.setItem(`vavlo_project_${state.projectId}`, JSON.stringify(payload));
        console.log('üíæ Saved to localStorage as backup');
        
        // Also store the HTML for download
        localStorage.setItem(`vavlo_html_${state.projectId}`, htmlContent);
        console.log('‚úÖ Generated standalone HTML file successfully');
        
        // Update share functionality to offer file download
        updateShareLinkForStaticFile();
        
      } catch(err) { 
        console.error('‚ùå HTML generation failed:', err);
        
        // Fallback: save to localStorage
        try {
          const payload = {
            projectId: state.projectId,
            createdAt: state.createdAt,
            expiresAt: state.expiresAt,
            accessCount: state.accessCount,
            versionOrder: state.versionOrder,
            currentVersion: state.currentVersion,
            versions: state.versions,
            updatedAt: new Date().toISOString()
          };
          localStorage.setItem(`vavlo_project_${state.projectId}`, JSON.stringify(payload));
          console.log('üíæ Saved to localStorage as fallback');
        } catch(localErr) {
          console.error('‚ùå All save methods failed:', localErr);
        }
      }
    }

    // Update share link to offer file download instead of API links
    function updateShareLinkForStaticFile() {
      if (shareInput && state.projectId) {
        // For now, show instructions for static file sharing
        const instructions = `Ready to share! Use "Download HTML" button to get a standalone file.`;
        shareInput.value = instructions;
        shareInput.style.fontSize = '12px';
        console.log('üîó Updated share instructions for static file approach');
      }
    }

    // Add download functionality
    function downloadProjectHTML() {
      const htmlContent = localStorage.getItem(`vavlo_html_${state.projectId}`);
      if (!htmlContent) {
        alert('No project HTML available. Please save the project first.');
        return;
      }

      const blob = new Blob([htmlContent], { type: 'text/html' });
      const url = URL.createObjectURL(blob);
      const link = document.createElement('a');
      link.href = url;
      link.download = `vavlo-project-${state.projectId.substring(0, 8)}.html`;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      console.log('üìÅ Downloaded project HTML file');
    }
    // Comprehensive share link fix - run this every time anything changes
    function forceCleanShareLink() {
      if (shareInput && state.projectId) {
        const cleanUrl = `${location.origin}${location.pathname}?shared=${state.projectId}`;
        shareInput.value = cleanUrl;
        console.log('FORCED clean share URL:', cleanUrl);
        return cleanUrl;
      }
      return null;
    }

    // Run clean share link fix on all major events
    function autoSave(){ 
      if (state.projectId) {
        forceCleanShareLink(); // Fix share link before saving
        saveProject(); 
      }
    }

    // Load from JSONBin.io with fallback
    async function loadProjectFromShared(sharedVal){
      try{
        console.log('üîÑ Loading shared project from JSONBin...');
        console.log('- Input value:', sharedVal);
        
        let id = null;
        
        // Handle different URL formats
        if (sharedVal.includes('://')) {
          console.log('üìã Detected old URL format, extracting ID...');
          try{
            const u = new URL(sharedVal);
            const m = u.pathname.match(/\/([^\/]+)(?:\.json)?$/);
            id = m ? m[1] : null;
          }catch(urlErr){
            id = sharedVal.split('/').pop().replace(/\.json$/, '');
          }
        } else {
          console.log('üìã Detected clean format (just project ID)');
          id = sharedVal.trim();
        }

        console.log('‚úÖ Final extracted ID:', id);
        if (!id || id.length < 10) {
          throw new Error(`Invalid project ID format: "${id}" (length: ${id ? id.length : 0})`);
        }

        // Try loading from JSONBin first
        let data = null;
        if (workerBase === 'jsonbin') {
          try {
            // Check if we have a bin ID stored locally for this project
            const binId = localStorage.getItem(`vavlo_bin_${id}`);
            
            if (binId) {
              console.log('üì° Attempting to fetch from JSONBin with bin ID:', binId);
              
              const response = await fetch(`${JSONBIN_CONFIG.apiUrl}/${binId}`, {
                method: 'GET',
                headers: {
                  'Content-Type': 'application/json'
                }
              });
              
              console.log('üì° JSONBin response status:', response.status);
              
              if (response.ok) {
                const result = await response.json();
                data = result.record || result; // JSONBin wraps data in 'record' property
                console.log('‚úÖ Successfully loaded from JSONBin');
                console.log('- Data keys:', Object.keys(data));
              } else {
                console.log('‚ùå JSONBin failed:', response.status);
              }
            } else {
              console.log('‚ö†Ô∏è No bin ID found for project:', id);
              console.log('- This might be a project created before JSONBin integration');
            }
          } catch(jsonbinErr) {
            console.log('‚ùå JSONBin request failed:', jsonbinErr.message);
          }
        } else {
          console.log('‚ö†Ô∏è JSONBin not available, skipping...');
        }

        // Fallback to localStorage if JSONBin failed
        if (!data) {
          try {
            const localKey = `vavlo_project_${id}`;
            console.log('üíæ Checking localStorage for key:', localKey);
            const localData = localStorage.getItem(localKey);
            if (localData) {
              data = JSON.parse(localData);
              console.log('‚úÖ Successfully loaded from localStorage fallback');
              console.log('- Data keys:', Object.keys(data));
            } else {
              console.log('‚ùå No data found in localStorage either');
            }
          } catch(localErr) {
            console.log('‚ùå localStorage fallback failed:', localErr.message);
          }
        }

        if (!data) {
          throw new Error('Project not found in JSONBin or localStorage. The project may not have been saved successfully, or the link is invalid.');
        }
        
        console.log('üìä Processing loaded data...');
        console.log('- Project ID:', data.projectId);
        console.log('- Created:', data.createdAt);
        console.log('- Current access count:', data.accessCount);
        
        state.projectId = data.projectId;
        state.createdAt = data.createdAt;
        state.expiresAt = data.expiresAt;
        
        // Increment access count and update display immediately
        state.accessCount = (data.accessCount || 0) + 1;
        console.log('üìà Incremented access count to:', state.accessCount);
        updateExpiryUI();
        
        state.versionOrder = data.versionOrder || [];
        state.versions = data.versions || {};
        state.currentVersion = data.currentVersion || (data.versionOrder && data.versionOrder[0]);

        console.log('üé® Setting up UI...');
        setVersions(state.versionOrder);
        if (state.currentVersion && state.versions[state.currentVersion]) {
          renderAll();
          console.log('‚úÖ Rendered successfully');
        } else {
          console.log('‚ö†Ô∏è No valid version to render');
        }

        // Update share input with clean format
        if (shareInput){
          const cleanUrl = `${location.origin}${location.pathname}?shared=${state.projectId}`;
          shareInput.value = cleanUrl;
          console.log('üîó Updated share link to clean format:', cleanUrl);
        }
        
        // Save the incremented access count back to database
        console.log('üíæ Saving updated access count...');
        await saveProject();
        console.log('‚úÖ Load process completed successfully');
        
      }catch(err){
        console.error('‚ùå Load process failed:', err);
        alert(`Could not load shared project: ${err.message}`);
      }
    }

    // Utils
    function formatTime(iso){ try{ const d = new Date(iso); return d.toLocaleString(); } catch{ return '' } }
    function truncate(str, n){ return (str||'').length > n ? (str||'').slice(0,n-1)+'‚Ä¶' : (str||''); }
    function sanitize(s){ return (s||'').replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[c])); }
    function cryptoRandomId(len){ const arr = new Uint8Array(len); (crypto||window.crypto).getRandomValues(arr); const abc = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'; let out=''; for(const n of arr){ out += abc[n % abc.length]; } return out; }

    function updateExpiryUI(){
      if (!state.expiresAt){ expiresText.textContent = '-'; return; }
      const now = Date.now(); const exp = new Date(state.expiresAt).getTime();
      const days = Math.max(0, Math.ceil((exp - now) / (1000*60*60*24)));
      expiresText.textContent = `${new Date(state.expiresAt).toLocaleDateString()} (${days}d)`;
      accessText.textContent = String(state.accessCount || 0);
    }

    // Init with share link debugging
    (async function init(){
      await resolveWorkerBase();

      const shared = new URLSearchParams(location.search).get('shared');
      if (shared){
        state.sharedMode = true;
        uploadBtn.disabled = true;
        uploadBtn.title = 'Uploads disabled for shared viewers';
        await loadProjectFromShared(shared);
        return;
      }
      
      await ensureProjectIdAndLink();
      setVersions([]);
      updateExpiryUI();
      
      // Force clean share link on every page load
      setTimeout(() => {
        if (shareInput && state.projectId) {
          const cleanUrl = `${location.origin}${location.pathname}?shared=${state.projectId}`;
          shareInput.value = cleanUrl;
          console.log('INIT: Forced clean share URL:', cleanUrl);
        }
      }, 100);
    })();
  </script>
</body>
</html>
