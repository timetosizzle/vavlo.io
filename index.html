<!--
QUICK NAV
[LAYOUT] Topbar .............. search: [SEC:TOPBAR]
[LAYOUT] Share Strip .......... search: [SEC:SHARE]
[LAYOUT] Stage/Viewport ....... search: [SEC:STAGE]
[LAYOUT] Sidebar/Comments ..... search: [SEC:SIDEBAR]
[STATE]  App State ............ search: [SEC:STATE]
[UI]     Zoom Controls ........ search: [SEC:ZOOM]
[UI]     Version Dropdown ..... search: [SEC:VERSIONS]
[ACTIONS] Comment Actions ..... search: [SEC:ACTIONS]
[RENDER] Markers & Comments ... search: [SEC:RENDER]
[UTIL]   Helpers .............. search: [SEC:UTIL]
-->
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Vavlo - Image Annotation Tool</title>
  <style>
    :root{
      --bg:#0f1221;
      --panel:#171a2c;
      --panel-2:#1f2340;
      --line:#2b315a;
      --text:#e7e9ff;
      --muted:#a6abd3;
      --pink:#ff2b85;
      --pink-600:#e32676;
      --gray:#6b7280; /* medium gray */
      --danger:#ef4444;
      --ok:#10b981;
      --yellow:#f59e0b;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0; background:var(--bg); color:var(--text); font:14px/1.35 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Helvetica, Arial;
    }
    a{color:inherit}

    /* Top bar */
    .topbar{
      display:flex; align-items:center; gap:16px; padding:10px 14px; background:var(--panel); border-bottom:1px solid var(--line);
      position:sticky; top:0; z-index:50;
    }
    .brand{display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.3px}
    .brand img{height:22px}
    .spacer{flex:1}
    .versions{display:flex; align-items:center; gap:8px}
    select, .btn{ appearance:none; border:1px solid var(--line); background:var(--panel-2); color:var(--text); border-radius:8px; padding:8px 10px; cursor:pointer }
    select:focus, .btn:focus{ outline:2px solid var(--pink); outline-offset:2px }

    .zoom-group{display:flex; align-items:center; gap:8px}
    .icon-btn{width:34px; height:34px; display:inline-grid; place-items:center; border-radius:8px}

    /* Share strip */
    .share-strip{display:flex; align-items:center; gap:12px; padding:10px 14px; background:var(--panel-2); border-bottom:1px solid var(--line)}
    .pill{display:inline-flex; align-items:center; gap:8px; padding:6px 10px; border:1px solid var(--line); border-radius:999px; color:var(--muted)}
    .share-strip .btn{background:transparent}
    .btn.primary{background:var(--pink); border-color:transparent}

    /* Layout */
    .wrap{display:grid; grid-template-columns: 1fr 360px; height:calc(100% - 94px)}
    .canvas-area{position:relative; overflow:auto; background:radial-gradient(1200px 1200px at 50% -10%, #1a1f3e, #0f1221 60%)}
    .sidebar{border-left:1px solid var(--line); background:var(--panel); overflow:auto}

    /* Drop zone */
    .dropzone{border:2px dashed var(--line); border-radius:16px; padding:24px; margin:16px; text-align:center; background:rgba(255,255,255,0.02)}
    .dropzone .logo{display:block; margin:0 auto 12px auto; height:42px}
    .dropzone h3{margin:6px 0 4px 0}
    .muted{color:var(--muted)}

    /* Image stage */
    .stage{position:relative; margin:16px; border:1px solid var(--line); border-radius:12px; overflow:hidden; background:#0c0f22}
    .image-viewport{ position:relative; width:100%; height:72vh; overflow:auto; background:#0c0f22 }
    .image-inner{ position:relative; transform-origin: top left; }
    .image-inner img{ display:block; max-width:none; /* we control size via scale */ }

    /* Markers */
    .marker{ position:absolute; width:22px; height:22px; border-radius:999px; display:grid; place-items:center; color:#fff; font-size:12px; font-weight:700; cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.35); transform: translate(-50%, -50%); }
    .marker.unresolved{ background:var(--pink) }
    .marker.resolved{ background:var(--gray) }

    /* Sidebar comments */
    .side-head{ display:flex; align-items:center; justify-content:space-between; padding:12px 14px; border-bottom:1px solid var(--line) }
    .comments{ padding:8px 10px }
    .comment{ border:1px solid var(--line); border-radius:12px; padding:10px; margin-bottom:10px; background:var(--panel-2)}
    .comment .row{ display:flex; align-items:center; gap:8px; margin-bottom:6px }
    .badge{ background:var(--pink); color:#fff; font-weight:800; padding:2px 8px; border-radius:999px }
    .badge.resolved{ background:var(--gray) }
    .comment .meta{ color:var(--muted); font-size:12px }
    .comment .text{ margin:6px 0 10px 0 }
    .comment-actions{ display:flex; flex-wrap:wrap; gap:6px }
    .comment-actions .btn{ color:#fff; border:none }
    .btn.resolve.unresolved{ background:var(--pink) }
    .btn.resolve.resolved{ background:var(--gray) }
    .btn.reply{ background:#3b82f6 }
    .btn.edit{ background:#8b5cf6 }
    .btn.delete{ background:var(--danger) }

    /* Small helpers */
    .sr{position:absolute; left:-9999px}
  </style>
</head>
<body>
  <!-- Top bar with version select and zoom controls to the right of it -->
  <!-- [SEC:TOPBAR] -->
  <div class="topbar">
    <div class="brand">
      <img src="Vavlo - logo- white@1000x.png" alt="Vavlo" />
      <span>Vavlo</span>
    </div>
    <div class="versions">
      <label for="version" class="sr">Version</label>
      <select id="version" title="Version" data-testid="version-select"></select>
    </div>
    <div class="zoom-group" style="margin-left:6px">
      <button class="btn icon-btn" id="zoomOut" data-testid="btn-zoom-out" title="Zoom out" aria-label="Zoom out">âˆ’</button>
      <button class="btn icon-btn" id="zoomReset" data-testid="btn-zoom-reset" title="Reset zoom" aria-label="Reset zoom">100%</button>
      <button class="btn icon-btn" id="zoomIn" data-testid="btn-zoom-in" title="Zoom in" aria-label="Zoom in">+</button>
    </div>
    <div class="spacer"></div>
    <button class="btn">Share</button>
  </div>

  <!-- Share details always visible to any viewer -->
  <!-- [SEC:SHARE] -->
  <div class="share-strip">
    <span class="pill">Expires: <strong id="expiresText">Oct 31, 2025</strong></span>
    <button class="btn">Copy Share Link</button>
    <button class="btn primary" id="uploadNewVersion" data-testid="btn-upload-version">Upload New Version</button>
  </div>

  <div class="wrap">
    <main class="canvas-area">
      <div class="dropzone" id="dropzone">
        <img class="logo" src="Vavlo - logo- white@1000x.png" alt="Vavlo" />
        <h3>Drag and drop an image</h3>
        <div class="muted">or click to choose a file</div>
        <input id="fileInput" type="file" accept="image/*" hidden />
      </div>

      <!-- [SEC:STAGE] -->
      <section class="stage" id="stage" hidden>
        <div class="image-viewport" id="viewport">
          <div class="image-inner" id="imageInner">
            <img id="img" alt="Uploaded" />
            <!-- markers get injected here -->
          </div>
        </div>
      </section>
    </main>

    <!-- [SEC:SIDEBAR] -->
    <aside class="sidebar">
      <div class="side-head">
        <strong>Comments</strong>
        <button class="btn" id="addDummy">Add sample</button>
      </div>
      <div id="comments" class="comments"></div>
    </aside>
  </div>

  <script>
    /* EVENT MAP
    click #zoomIn ........................ onZoomIn
    click #zoomOut ....................... onZoomOut
    click #zoomReset ..................... fitToViewport
    click .image-inner ................... addComment at click coords
    click [data-action=toggle-resolve] ... onToggleResolve
    click [data-action=delete] ........... onDeleteComment
    input .text[data-id] ................. syncCommentText
    */

    // [SEC:VERSIONS]

    /* Version dropdown management */
    const versionSelect = document.getElementById('version');
    let versions = [];

    function setVersions(list){
      const uniq = Array.from(new Set(list));
      uniq.sort((a,b)=> (parseInt(b.replace(/\D/g,''))||0) - (parseInt(a.replace(/\D/g,''))||0));
      versions = uniq;
      versionSelect.innerHTML = '';
      uniq.forEach(v => {
        const opt = document.createElement('option');
        opt.value = v;
        opt.textContent = v;
        versionSelect.appendChild(opt);
      });
      if (versionSelect.options.length) versionSelect.selectedIndex = 0;
    }

    // Initialize with only newest once
    setVersions(['v1']);

    document.addEventListener('DOMContentLoaded', () => {
      const uploadBtn = document.getElementById('uploadNewVersion');
      if (uploadBtn){
        uploadBtn.addEventListener('click', () => {
          const currentMax = versions.reduce((m,v)=> Math.max(m, parseInt(v.replace(/\D/g,''))||0), 0);
          const next = `v${currentMax + 1}`;
          setVersions([next, ...versions]);
        });
      }
    });
    /**
     * Simple image annotation scaffold
     * - Markers live inside .image-inner so they scale with the image
     * - Positions are saved in image-native percentages so zoom does not drift
     */

    // [SEC:STATE]
/** @typedef {{ id:number, xPct:number, yPct:number, text:string, resolved:boolean }} CommentItem */
/** @type {{ scale:number, minScale:number, maxScale:number, step:number, nextId:number, imgNatural:{w:number,h:number}, comments:CommentItem[] }} */
const state = {
      scale: 1,
      minScale: 0.5,
      maxScale: 4,
      step: 0.25,
      nextId: 1,
      imgNatural: { w: 0, h: 0 },
      comments: [] // {id, xPct, yPct, text, resolved}
    };

    // Elements
    const dropzone = document.getElementById('dropzone');
    const fileInput = document.getElementById('fileInput');
    const stage = document.getElementById('stage');
    const img = document.getElementById('img');
    const imageInner = document.getElementById('imageInner');
    const viewport = document.getElementById('viewport');
    const commentsEl = document.getElementById('comments');

    const zoomInBtn = document.getElementById('zoomIn');
    const zoomOutBtn = document.getElementById('zoomOut');
    const zoomResetBtn = document.getElementById('zoomReset');

    // Dropzone wiring
    dropzone.addEventListener('click', () => fileInput.click());
    dropzone.addEventListener('dragover', e => { e.preventDefault(); dropzone.style.borderColor = 'var(--pink)'; });
    dropzone.addEventListener('dragleave', e => { dropzone.style.borderColor = 'var(--line)'; });
    dropzone.addEventListener('drop', e => {
      e.preventDefault();
      dropzone.style.borderColor = 'var(--line)';
      const file = e.dataTransfer.files && e.dataTransfer.files[0];
      if (file) loadImageFile(file);
    });
    fileInput.addEventListener('change', e => {
      const file = e.target.files && e.target.files[0];
      if (file) loadImageFile(file);
    });

    function loadImageFile(file){
      const url = URL.createObjectURL(file);
      img.onload = () => {
        state.imgNatural.w = img.naturalWidth;
        state.imgNatural.h = img.naturalHeight;
        // Set the inner box to natural size so transform scale is accurate
        imageInner.style.width = state.imgNatural.w + 'px';
        imageInner.style.height = state.imgNatural.h + 'px';
        stage.hidden = false;
        dropzone.hidden = true;
        fitToViewport();
      };
      img.src = url;
    }

    function applyScale(){
      imageInner.style.transform = `scale(${state.scale})`;
      zoomResetBtn.textContent = Math.round(state.scale * 100) + '%';
    }

    function fitToViewport(){
      // Fit image to viewport width by default
      const vw = viewport.clientWidth - 20; // small padding room
      const vh = viewport.clientHeight - 20;
      const sx = vw / state.imgNatural.w;
      const sy = vh / state.imgNatural.h;
      state.scale = Math.max( Math.min(sx, sy), 0.5 );
      applyScale();
    }

    window.addEventListener('resize', () => {
      if (!stage.hidden) fitToViewport();
    });

    zoomInBtn.addEventListener('click', () => { state.scale = Math.min(state.maxScale, +(state.scale + state.step).toFixed(2)); applyScale(); });
    zoomOutBtn.addEventListener('click', () => { state.scale = Math.max(state.minScale, +(state.scale - state.step).toFixed(2)); applyScale(); });
    zoomResetBtn.addEventListener('click', () => { fitToViewport(); });

    // Add marker by clicking the image
    imageInner.addEventListener('click', (e) => {
      // Avoid adding when clicking on a marker
      if (e.target.classList.contains('marker')) return;

      const rect = imageInner.getBoundingClientRect();
      const xScaled = e.clientX - rect.left;
      const yScaled = e.clientY - rect.top;
      // Remove the scale to compute native coordinates
      const x = xScaled / state.scale;
      const y = yScaled / state.scale;
      const xPct = (x / state.imgNatural.w) * 100;
      const yPct = (y / state.imgNatural.h) * 100;

      addComment({ xPct, yPct, text: 'New comment', resolved: false });
    });

    function addComment({ xPct, yPct, text, resolved }){
      const id = state.nextId++;
      state.comments.push({ id, xPct, yPct, text, resolved });
      renderMarker({ id, xPct, yPct, resolved });
      renderComments();
    }

    function renderMarker({ id, xPct, yPct, resolved }){
      const existing = imageInner.querySelector(`[data-id="${id}"]`);
      if (existing) existing.remove();
      const el = document.createElement('div');
      el.className = `marker ${resolved ? 'resolved' : 'unresolved'}`;
      el.dataset.id = String(id);
      el.style.left = xPct + '%';
      el.style.top = yPct + '%';
      el.textContent = id;
      el.setAttribute('data-testid', `marker-${id}`);
      imageInner.appendChild(el);
    }

    function renderComments(){
      commentsEl.innerHTML = '';
      state.comments.forEach(c => {
        const card = document.createElement('div');
        card.className = 'comment';
        card.innerHTML = `
          <div class="row">
            <span class="badge ${c.resolved ? 'resolved' : ''}">#${c.id}</span>
            <span class="meta">${c.resolved ? 'Resolved' : 'Unresolved'}</span>
          </div>
          <div class="text" contenteditable="true" data-id="${c.id}">${c.text}</div>
          <div class="comment-actions">
            <button class="btn resolve ${c.resolved ? 'resolved' : 'unresolved'}" data-action="toggle-resolve" data-id="${c.id}" data-testid="btn-resolve-${c.id}">${c.resolved ? 'Unresolve' : 'Resolve'}</button>
            <button class="btn reply" data-action="reply" data-id="${c.id}">Reply</button>
            <button class="btn edit" data-action="edit" data-id="${c.id}">Edit</button>
            <button class="btn delete" data-action="delete" data-id="${c.id}">Delete</button>
          </div>
        `;
        commentsEl.appendChild(card);
      });
    }

    // Action handling with delegation
    commentsEl.addEventListener('click', (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      const id = +(t.getAttribute('data-id') || 0);
      if (!id) return;
      const c = state.comments.find(x => x.id === id);
      if (!c) return;

      const action = t.getAttribute('data-action');
      if (action === 'toggle-resolve'){
        console.groupCollapsed('[RESOLVE] toggle', { id, to: !c.resolved ? 'resolved' : 'unresolved' });
        c.resolved = !c.resolved;
        console.groupEnd();
        // Update marker
        renderMarker(c);
        // Re-render comments to refresh buttons, badge colors, and text
        renderComments();
        return;
      }
      if (action === 'delete'){
        // Remove comment and marker
        state.comments = state.comments.filter(x => x.id !== id);
        const m = imageInner.querySelector(`[data-id="${id}"]`);
        if (m) m.remove();
        renderComments();
        return;
      }
      if (action === 'edit'){
        // Focus editable text
        const editable = commentsEl.querySelector(`.text[data-id="${id}"]`);
        if (editable){ editable.focus(); }
        return;
      }
      if (action === 'reply'){
        alert('Reply clicked for #' + id);
        return;
      }
    });

    // Keep editable text synced
    commentsEl.addEventListener('input', (e) => {
      const t = e.target;
      if (!(t instanceof HTMLElement)) return;
      if (t.classList.contains('text')){
        const id = +(t.getAttribute('data-id') || 0);
        const c = state.comments.find(x => x.id === id);
        if (c) c.text = t.textContent || '';
      }
    });

    // Demo seed
    document.getElementById('addDummy').addEventListener('click', () => {
      if (!img.src){
        // Load a tiny placeholder canvas if no image yet
        const ph = document.createElement('canvas');
        ph.width = 1200; ph.height = 800;
        const cx = ph.getContext('2d');
        cx.fillStyle = '#0c0f22'; cx.fillRect(0,0,ph.width,ph.height);
        cx.strokeStyle = '#1f2a5a'; cx.lineWidth = 6; cx.strokeRect(20,20,ph.width-40,ph.height-40);
        cx.fillStyle = '#ffffff'; cx.font = '28px system-ui'; cx.fillText('Drop an image to annotate', 36, 64);
        img.onload = () => {
          state.imgNatural.w = img.naturalWidth;
          state.imgNatural.h = img.naturalHeight;
          imageInner.style.width = state.imgNatural.w + 'px';
          imageInner.style.height = state.imgNatural.h + 'px';
          stage.hidden = false; dropzone.hidden = true; fitToViewport();
        }
        img.src = ph.toDataURL();
      }
      // Add two sample comments
      addComment({ xPct: 30, yPct: 30, text: 'Tighten crop on subject', resolved: false });
      addComment({ xPct: 72, yPct: 58, text: 'Color balance a bit cool', resolved: true });
    });

    // Make sure markers stay aligned when user scrolls the viewport
    // (they do, since they live inside the scaled element). Nothing else needed here.
  </script>
</body>
</html>
